"""Utility functions for django numerics."""

from __future__ import unicode_literals  # noqa

import six
import json
from django.core.exceptions import ImproperlyConfigured
from django.conf import settings

from cryptography.fernet import Fernet
import binascii

_FERNET_KEY = 'fernet'

_CACHE = {}


def get_fernet():
    """Return a fernet object. Object is encoded on module level.

    Fernet object gets a long time to create so we are creating it only once
    per runtime.

    """
    if _FERNET_KEY not in _CACHE:
        try:
            key = six.b(getattr(settings, 'DJANGO_NUMERICS_SECRET_KEY', ''))
            if not key:
                # same error if key is not hexedecimal.
                # that way 2 errors will be handled in same place.
                raise binascii.Error
            _CACHE[_FERNET_KEY] = Fernet(key)
        except binascii.Error:
            raise ImproperlyConfigured('DJANGO_NUMERICS_SECRET_KEY must be a '
                                       'hexedecimal value. Here is one that '
                                       'is randomly generated for you ;) '
                                       '{}'.format(Fernet.generate_key()))
    return _CACHE[_FERNET_KEY]


def encrypt(data):
    """Encrypt given object.

    Since fernet objects works with bytes. We are serializing object
    into json. That way data can be any serialziable object.
    """
    data_json = json.dumps(data)
    if isinstance(data, six.text_type):
        data = data.encode('utf-8')
    data_bytes = six.b(data_json)
    return get_fernet().encrypt(data_bytes).decode('utf-8')


def decrypt(data):
    """Decrypt data string.

    Data string must be generated by encrypt method.
    If DJANGO_NUMERICS_SECRET_KEY or DJANGO_NUMERICS_SALT is changed after.
    encrypted string is created. decrypt method will raise an exception.
    """
    # make sure that data is str or bytes string
    if isinstance(data, six.text_type):
        data = data.encode('utf-8')
    elif isinstance(data, six.binary_type):
        # it is already in right format
        pass
    else:
        ValueError('data should have type of either str or bytes')

    decrypted_data = get_fernet().decrypt(data).decode('utf-8')
    return json.loads(decrypted_data)
